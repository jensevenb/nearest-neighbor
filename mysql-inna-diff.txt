commit ab5069dacaf345ee090a05a97c8737e6e60f101c
Author: Jens Even Berg Blomsøy <jens.even.blomsoy@oracle.com>
Date:   Wed May 31 10:50:51 2017 +0200

    wl9449
    InnoDB: Distance scan of R-Tree for Nearest Neighbor Searches

diff --git a/client/mysql.cc b/client/mysql.cc
index 810db2e..e216be0 100644
--- a/client/mysql.cc
+++ b/client/mysql.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -5571,7 +5571,7 @@ static void nice_time(double sec,char *buff,bool part_second)
     buff=my_stpcpy(buff," min ");
   }
   if (part_second)
-    sprintf(buff,"%.2f sec",sec);
+    sprintf(buff,"%.8f sec",sec);
   else
     sprintf(buff,"%d sec",(int) sec);
 }
diff --git a/include/my_base.h b/include/my_base.h
index 4ce46ba..d855d9e 100644
--- a/include/my_base.h
+++ b/include/my_base.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -79,6 +79,7 @@ enum ha_rkey_function {
   HA_READ_MBR_WITHIN,             /* Minimum Bounding Rectangle within */
   HA_READ_MBR_DISJOINT,           /* Minimum Bounding Rectangle disjoint */
   HA_READ_MBR_EQUAL,              /* Minimum Bounding Rectangle equal */
+  HA_READ_NEAREST_NEIGHBOR,       /* Finds the k nearest neighbors. */
   HA_READ_INVALID= -1             /* Invalid enumeration value, always last. */
 };
 
diff --git a/mysql-test/suite/gis/t/knn.test b/mysql-test/suite/gis/t/knn.test
new file mode 100644
index 0000000..7b929fa
--- /dev/null
+++ b/mysql-test/suite/gis/t/knn.test
@@ -0,0 +1,37 @@
+###############################################################################
+#                                                                             #
+# This test is aimed to focus on the properties and attributes of the         #
+# Mutator ST_X and ST_Y                                                       #
+# point Geometry classes, and the functionality of ST_X() and ST_Y().         #
+#                                                                             #
+#                                                                             #
+# Creation Date: 2016-07-25                                                   #
+# Author : Jens Even Berg Blomsøy                                             #
+#                                                                             #
+###############################################################################
+
+
+###############################################################################
+# Creating the spatial objects                                                #
+###############################################################################
+
+--echo # Creating the spatial objects
+
+CREATE TABLE worst_case (g GEOMETRY NOT NULL, SPATIAL INDEX(g));
+
+
+###############################################################################
+# POINT                                                                       #
+###############################################################################
+
+INSERT INTO worst_case (g) values (POINT(0, 0)), (POINT(-1, -1)), (POINT(2, 2)), (POINT(-3, -3)), (POINT(4, 4)), (POINT(-5, -5)), (POINT(6, 6)), (POINT(-7, -7)), (POINT(8, 8)), (POINT(-9, -9)), (POINT(10, 10)), (POINT(-11, -11)), (POINT(12, 12)), (POINT(-13, -13)), (POINT(14, 14)), (POINT(-15, -15)), (POINT(16, 16)), (POINT(-17, -17)), (POINT(18, 18)), (POINT(-19, -19)), (POINT(20, 20)), (POINT(-21, -21)), (POINT(22, 22)), (POINT(-23, -23)), (POINT(24, 24)), (POINT(-25, -25)), (POINT(26, 26)), (POINT(-27, -27)), (POINT(28, 28)), (POINT(-29, -29)), (POINT(30, 30)), (POINT(-31, -31)), (POINT(32, 32)), (POINT(-33, -33)), (POINT(34, 34)), (POINT(-35, -35)), (POINT(36, 36)), (POINT(-37, -37)), (POINT(38, 38)), (POINT(-39, -39)), (POINT(40, 40)), (POINT(-41, -41)), (POINT(42, 42)), (POINT(-43, -43)), (POINT(44, 44)), (POINT(-45, -45)), (POINT(46, 46)), (POINT(-47, -47)), (POINT(48, 48)), (POINT(-49, -49)), (POINT(50, 50)), (POINT(-51, -51)), (POINT(52, 52)), (POINT(-53, -53)), (POINT(54, 54)), (POINT(-55, -55)), (POINT(56, 56)), (POINT(-57, -57)), (POINT(58, 58)), (POINT(-59, -59)), (POINT(60, 60)), (POINT(-61, -61)), (POINT(62, 62)), (POINT(-63, -63)), (POINT(64, 64)), (POINT(-65, -65)), (POINT(66, 66)), (POINT(-67, -67)), (POINT(68, 68)), (POINT(-69, -69)), (POINT(70, 70)), (POINT(-71, -71)), (POINT(72, 72)), (POINT(-73, -73)), (POINT(74, 74)), (POINT(-75, -75)), (POINT(76, 76)), (POINT(-77, -77)), (POINT(78, 78)), (POINT(-79, -79)), (POINT(80, 80)), (POINT(-81, -81)), (POINT(82, 82)), (POINT(-83, -83)), (POINT(84, 84)), (POINT(-85, -85)), (POINT(86, 86)), (POINT(-87, -87)), (POINT(88, 88)), (POINT(-89, -89)), (POINT(90, 90)), (POINT(-91, -91)), (POINT(92, 92)), (POINT(-93, -93)), (POINT(94, 94)), (POINT(-95, -95)), (POINT(96, 96)), (POINT(-97, -97)), (POINT(98, 98)), (POINT(-99, -99)), (POINT(100, 100)), (POINT(-101, -101)), (POINT(102, 102)), (POINT(-103, -103)), (POINT(104, 104)), (POINT(-105, -105)), (POINT(106, 106)), (POINT(-107, -107)), (POINT(108, 108)), (POINT(-109, -109)), (POINT(110, 110)), (POINT(-111, -111)), (POINT(112, 112)), (POINT(-113, -113)), (POINT(114, 114)), (POINT(-115, -115)), (POINT(116, 116)), (POINT(-117, -117)), (POINT(118, 118)), (POINT(-119, -119)), (POINT(120, 120)), (POINT(-121, -121)), (POINT(122, 122)), (POINT(-123, -123)), (POINT(124, 124)), (POINT(-125, -125)), (POINT(126, 126)), (POINT(-127, -127)), (POINT(128, 128)), (POINT(-129, -129)), (POINT(130, 130)), (POINT(-131, -131)), (POINT(132, 132)), (POINT(-133, -133)), (POINT(134, 134)), (POINT(-135, -135)), (POINT(136, 136)), (POINT(-137, -137)), (POINT(138, 138)), (POINT(-139, -139)), (POINT(140, 140)), (POINT(-141, -141)), (POINT(142, 142)), (POINT(-143, -143)), (POINT(144, 144)), (POINT(-145, -145)), (POINT(146, 146)), (POINT(-147, -147)), (POINT(148, 148)), (POINT(-149, -149)), (POINT(150, 150)), (POINT(-151, -151)), (POINT(152, 152)), (POINT(-153, -153)), (POINT(154, 154)), (POINT(-155, -155)), (POINT(156, 156)), (POINT(-157, -157)), (POINT(158, 158)), (POINT(-159, -159)), (POINT(160, 160)), (POINT(-161, -161)), (POINT(162, 162)), (POINT(-163, -163)), (POINT(164, 164)), (POINT(-165, -165)), (POINT(166, 166)), (POINT(-167, -167)), (POINT(168, 168)), (POINT(-169, -169)), (POINT(170, 170)), (POINT(-171, -171)), (POINT(172, 172)), (POINT(-173, -173)), (POINT(174, 174)), (POINT(-175, -175)), (POINT(176, 176)), (POINT(-177, -177)), (POINT(178, 178)), (POINT(-179, -179)), (POINT(180, 180)), (POINT(-181, -181)), (POINT(182, 182)), (POINT(-183, -183)), (POINT(184, 184)), (POINT(-185, -185)), (POINT(186, 186)), (POINT(-187, -187)), (POINT(188, 188)), (POINT(-189, -189)), (POINT(190, 190)), (POINT(-191, -191)), (POINT(192, 192)), (POINT(-193, -193)), (POINT(194, 194)), (POINT(-195, -195)), (POINT(196, 196)), (POINT(-197, -197)), (POINT(198, 198)), (POINT(-199, -199)), (POINT(200, 200)), (POINT(-201, -201)), (POINT(202, 202)), (POINT(-203, -203)), (POINT(204, 204)), (POINT(-205, -205)), (POINT(206, 206)), (POINT(-207, -207)), (POINT(208, 208)), (POINT(-209, -209)), (POINT(210, 210)), (POINT(-211, -211)), (POINT(212, 212)), (POINT(-213, -213)), (POINT(214, 214)), (POINT(-215, -215)), (POINT(216, 216)), (POINT(-217, -217)), (POINT(218, 218)), (POINT(-219, -219)), (POINT(220, 220)), (POINT(-221, -221)), (POINT(222, 222)), (POINT(-223, -223)), (POINT(224, 224)), (POINT(-225, -225)), (POINT(226, 226)), (POINT(-227, -227)), (POINT(228, 228)), (POINT(-229, -229)), (POINT(230, 230)), (POINT(-231, -231)), (POINT(232, 232)), (POINT(-233, -233)), (POINT(234, 234)), (POINT(-235, -235)), (POINT(236, 236)), (POINT(-237, -237)), (POINT(238, 238)), (POINT(-239, -239)), (POINT(240, 240)), (POINT(-241, -241)), (POINT(242, 242)), (POINT(-243, -243)), (POINT(244, 244)), (POINT(-245, -245)), (POINT(246, 246)), (POINT(-247, -247)), (POINT(248, 248)), (POINT(-249, -249)), (POINT(250, 250)), (POINT(-251, -251)), (POINT(252, 252)), (POINT(-253, -253)), (POINT(254, 254)), (POINT(-255, -255)), (POINT(256, 256)), (POINT(-257, -257)), (POINT(258, 258)), (POINT(-259, -259)), (POINT(260, 260)), (POINT(-261, -261)), (POINT(262, 262)), (POINT(-263, -263)), (POINT(264, 264)), (POINT(-265, -265)), (POINT(266, 266)), (POINT(-267, -267)), (POINT(268, 268)), (POINT(-269, -269)), (POINT(270, 270)), (POINT(-271, -271)), (POINT(272, 272)), (POINT(-273, -273)), (POINT(274, 274)), (POINT(-275, -275)), (POINT(276, 276)), (POINT(-277, -277)), (POINT(278, 278)), (POINT(-279, -279)), (POINT(280, 280)), (POINT(-281, -281)), (POINT(282, 282)), (POINT(-283, -283)), (POINT(284, 284)), (POINT(-285, -285)), (POINT(286, 286)), (POINT(-287, -287)), (POINT(288, 288)), (POINT(-289, -289)), (POINT(290, 290)), (POINT(-291, -291)), (POINT(292, 292)), (POINT(-293, -293)), (POINT(294, 294)), (POINT(-295, -295)), (POINT(296, 296)), (POINT(-297, -297)), (POINT(298, 298)), (POINT(-299, -299)), (POINT(300, 300)), (POINT(-301, -301)), (POINT(302, 302)), (POINT(-303, -303)), (POINT(304, 304)), (POINT(-305, -305)), (POINT(306, 306)), (POINT(-307, -307)), (POINT(308, 308)), (POINT(-309, -309)), (POINT(310, 310)), (POINT(-311, -311)), (POINT(312, 312)), (POINT(-313, -313)), (POINT(314, 314)), (POINT(-315, -315)), (POINT(316, 316)), (POINT(-317, -317)), (POINT(318, 318)), (POINT(-319, -319)), (POINT(320, 320)), (POINT(-321, -321)), (POINT(322, 322)), (POINT(-323, -323)), (POINT(324, 324)), (POINT(-325, -325)), (POINT(326, 326)), (POINT(-327, -327)), (POINT(328, 328)), (POINT(-329, -329)), (POINT(330, 330)), (POINT(-331, -331)), (POINT(332, 332)), (POINT(-333, -333)), (POINT(334, 334)), (POINT(-335, -335)), (POINT(336, 336)), (POINT(-337, -337)), (POINT(338, 338)), (POINT(-339, -339)), (POINT(340, 340)), (POINT(-341, -341)), (POINT(342, 342)), (POINT(-343, -343)), (POINT(344, 344)), (POINT(-345, -345)), (POINT(346, 346)), (POINT(-347, -347)), (POINT(348, 348)), (POINT(-349, -349)), (POINT(350, 350)), (POINT(-351, -351)), (POINT(352, 352)), (POINT(-353, -353)), (POINT(354, 354)), (POINT(-355, -355)), (POINT(356, 356)), (POINT(-357, -357)), (POINT(358, 358)), (POINT(-359, -359)), (POINT(360, 360)), (POINT(-361, -361)), (POINT(362, 362)), (POINT(-363, -363)), (POINT(364, 364)), (POINT(-365, -365)), (POINT(366, 366)), (POINT(-367, -367)), (POINT(368, 368)), (POINT(-369, -369)), (POINT(370, 370)), (POINT(-371, -371)), (POINT(372, 372)), (POINT(-373, -373)), (POINT(374, 374)), (POINT(-375, -375)), (POINT(376, 376)), (POINT(-377, -377)), (POINT(378, 378)), (POINT(-379, -379)), (POINT(380, 380)), (POINT(-381, -381)), (POINT(382, 382)), (POINT(-383, -383)), (POINT(384, 384)), (POINT(-385, -385)), (POINT(386, 386)), (POINT(-387, -387)), (POINT(388, 388)), (POINT(-389, -389)), (POINT(390, 390)), (POINT(-391, -391)), (POINT(392, 392)), (POINT(-393, -393)), (POINT(394, 394)), (POINT(-395, -395)), (POINT(396, 396)), (POINT(-397, -397)), (POINT(398, 398)), (POINT(-399, -399)), (POINT(400, 400)), (POINT(-401, -401)), (POINT(402, 402)), (POINT(-403, -403)), (POINT(404, 404)), (POINT(-405, -405)), (POINT(406, 406)), (POINT(-407, -407)), (POINT(408, 408)), (POINT(-409, -409)), (POINT(410, 410)), (POINT(-411, -411)), (POINT(412, 412)), (POINT(-413, -413)), (POINT(414, 414)), (POINT(-415, -415)), (POINT(416, 416)), (POINT(-417, -417)), (POINT(418, 418)), (POINT(-419, -419)), (POINT(420, 420)), (POINT(-421, -421)), (POINT(422, 422)), (POINT(-423, -423)), (POINT(424, 424)), (POINT(-425, -425)), (POINT(426, 426)), (POINT(-427, -427)), (POINT(428, 428)), (POINT(-429, -429)), (POINT(430, 430)), (POINT(-431, -431)), (POINT(432, 432)), (POINT(-433, -433)), (POINT(434, 434)), (POINT(-435, -435)), (POINT(436, 436)), (POINT(-437, -437)), (POINT(438, 438)), (POINT(-439, -439)), (POINT(440, 440)), (POINT(-441, -441)), (POINT(442, 442)), (POINT(-443, -443)), (POINT(444, 444)), (POINT(-445, -445)), (POINT(446, 446)), (POINT(-447, -447)), (POINT(448, 448)), (POINT(-449, -449)), (POINT(450, 450)), (POINT(-451, -451)), (POINT(452, 452)), (POINT(-453, -453)), (POINT(454, 454)), (POINT(-455, -455)), (POINT(456, 456)), (POINT(-457, -457)), (POINT(458, 458)), (POINT(-459, -459)), (POINT(460, 460)), (POINT(-461, -461)), (POINT(462, 462)), (POINT(-463, -463)), (POINT(464, 464)), (POINT(-465, -465)), (POINT(466, 466)), (POINT(-467, -467)), (POINT(468, 468)), (POINT(-469, -469)), (POINT(470, 470)), (POINT(-471, -471)), (POINT(472, 472)), (POINT(-473, -473)), (POINT(474, 474)), (POINT(-475, -475)), (POINT(476, 476)), (POINT(-477, -477)), (POINT(478, 478)), (POINT(-479, -479)), (POINT(480, 480)), (POINT(-481, -481)), (POINT(482, 482)), (POINT(-483, -483)), (POINT(484, 484)), (POINT(-485, -485)), (POINT(486, 486)), (POINT(-487, -487)), (POINT(488, 488)), (POINT(-489, -489)), (POINT(490, 490)), (POINT(-491, -491)), (POINT(492, 492)), (POINT(-493, -493)), (POINT(494, 494)), (POINT(-495, -495)), (POINT(496, 496)), (POINT(-497, -497)), (POINT(498, 498)), (POINT(-499, -499)), (POINT(500, 500)), (POINT(-501, -501)), (POINT(502, 502)), (POINT(-503, -503)), (POINT(504, 504)), (POINT(-505, -505)), (POINT(506, 506)), (POINT(-507, -507)), (POINT(508, 508)), (POINT(-509, -509)), (POINT(510, 510)), (POINT(-511, -511)), (POINT(512, 512)), (POINT(-513, -513)), (POINT(514, 514)), (POINT(-515, -515)), (POINT(516, 516)), (POINT(-517, -517)), (POINT(518, 518)), (POINT(-519, -519)), (POINT(520, 520)), (POINT(-521, -521)), (POINT(522, 522)), (POINT(-523, -523)), (POINT(524, 524)), (POINT(-525, -525)), (POINT(526, 526)), (POINT(-527, -527)), (POINT(528, 528)), (POINT(-529, -529)), (POINT(530, 530)), (POINT(-531, -531)), (POINT(532, 532)), (POINT(-533, -533)), (POINT(534, 534)), (POINT(-535, -535)), (POINT(536, 536)), (POINT(-537, -537)), (POINT(538, 538)), (POINT(-539, -539)), (POINT(540, 540)), (POINT(-541, -541)), (POINT(542, 542)), (POINT(-543, -543)), (POINT(544, 544)), (POINT(-545, -545)), (POINT(546, 546)), (POINT(-547, -547)), (POINT(548, 548)), (POINT(-549, -549)), (POINT(550, 550)), (POINT(-551, -551)), (POINT(552, 552)), (POINT(-553, -553)), (POINT(554, 554)), (POINT(-555, -555)), (POINT(556, 556)), (POINT(-557, -557)), (POINT(558, 558)), (POINT(-559, -559)), (POINT(560, 560)), (POINT(-561, -561)), (POINT(562, 562)), (POINT(-563, -563)), (POINT(564, 564)), (POINT(-565, -565)), (POINT(566, 566)), (POINT(-567, -567)), (POINT(568, 568)), (POINT(-569, -569)), (POINT(570, 570)), (POINT(-571, -571)), (POINT(572, 572)), (POINT(-573, -573)), (POINT(574, 574)), (POINT(-575, -575)), (POINT(576, 576)), (POINT(-577, -577)), (POINT(578, 578)), (POINT(-579, -579)), (POINT(580, 580)), (POINT(-581, -581)), (POINT(582, 582)), (POINT(-583, -583)), (POINT(584, 584)), (POINT(-585, -585)), (POINT(586, 586)), (POINT(-587, -587)), (POINT(588, 588)), (POINT(-589, -589)), (POINT(590, 590)), (POINT(-591, -591)), (POINT(592, 592)), (POINT(-593, -593)), (POINT(594, 594)), (POINT(-595, -595)), (POINT(596, 596)), (POINT(-597, -597)), (POINT(598, 598)), (POINT(-599, -599)), (POINT(600, 600)), (POINT(-601, -601)), (POINT(602, 602)), (POINT(-603, -603)), (POINT(604, 604)), (POINT(-605, -605)), (POINT(606, 606)), (POINT(-607, -607)), (POINT(608, 608)), (POINT(-609, -609)), (POINT(610, 610)), (POINT(-611, -611)), (POINT(612, 612)), (POINT(-613, -613)), (POINT(614, 614)), (POINT(-615, -615)), (POINT(616, 616)), (POINT(-617, -617)), (POINT(618, 618)), (POINT(-619, -619)), (POINT(620, 620)), (POINT(-621, -621)), (POINT(622, 622)), (POINT(-623, -623)), (POINT(624, 624)), (POINT(-625, -625)), (POINT(626, 626)), (POINT(-627, -627)), (POINT(628, 628)), (POINT(-629, -629)), (POINT(630, 630)), (POINT(-631, -631)), (POINT(632, 632)), (POINT(-633, -633)), (POINT(634, 634)), (POINT(-635, -635)), (POINT(636, 636)), (POINT(-637, -637)), (POINT(638, 638)), (POINT(-639, -639)), (POINT(640, 640)), (POINT(-641, -641)), (POINT(642, 642)), (POINT(-643, -643)), (POINT(644, 644)), (POINT(-645, -645)), (POINT(646, 646)), (POINT(-647, -647)), (POINT(648, 648)), (POINT(-649, -649)), (POINT(650, 650)), (POINT(-651, -651)), (POINT(652, 652)), (POINT(-653, -653)), (POINT(654, 654)), (POINT(-655, -655)), (POINT(656, 656)), (POINT(-657, -657)), (POINT(658, 658)), (POINT(-659, -659)), (POINT(660, 660)), (POINT(-661, -661)), (POINT(662, 662)), (POINT(-663, -663)), (POINT(664, 664)), (POINT(-665, -665)), (POINT(666, 666)), (POINT(-667, -667)), (POINT(668, 668)), (POINT(-669, -669)), (POINT(670, 670)), (POINT(-671, -671)), (POINT(672, 672)), (POINT(-673, -673)), (POINT(674, 674)), (POINT(-675, -675)), (POINT(676, 676)), (POINT(-677, -677)), (POINT(678, 678)), (POINT(-679, -679)), (POINT(680, 680)), (POINT(-681, -681)), (POINT(682, 682)), (POINT(-683, -683)), (POINT(684, 684)), (POINT(-685, -685)), (POINT(686, 686)), (POINT(-687, -687)), (POINT(688, 688)), (POINT(-689, -689)), (POINT(690, 690)), (POINT(-691, -691)), (POINT(692, 692)), (POINT(-693, -693)), (POINT(694, 694)), (POINT(-695, -695)), (POINT(696, 696)), (POINT(-697, -697)), (POINT(698, 698)), (POINT(-699, -699)), (POINT(700, 700)), (POINT(-701, -701)), (POINT(702, 702)), (POINT(-703, -703)), (POINT(704, 704)), (POINT(-705, -705)), (POINT(706, 706)), (POINT(-707, -707)), (POINT(708, 708)), (POINT(-709, -709)), (POINT(710, 710)), (POINT(-711, -711)), (POINT(712, 712)), (POINT(-713, -713)), (POINT(714, 714)), (POINT(-715, -715)), (POINT(716, 716)), (POINT(-717, -717)), (POINT(718, 718)), (POINT(-719, -719)), (POINT(720, 720)), (POINT(-721, -721)), (POINT(722, 722)), (POINT(-723, -723)), (POINT(724, 724)), (POINT(-725, -725)), (POINT(726, 726)), (POINT(-727, -727)), (POINT(728, 728)), (POINT(-729, -729)), (POINT(730, 730)), (POINT(-731, -731)), (POINT(732, 732)), (POINT(-733, -733)), (POINT(734, 734)), (POINT(-735, -735)), (POINT(736, 736)), (POINT(-737, -737)), (POINT(738, 738)), (POINT(-739, -739)), (POINT(740, 740)), (POINT(-741, -741)), (POINT(742, 742)), (POINT(-743, -743)), (POINT(744, 744)), (POINT(-745, -745)), (POINT(746, 746)), (POINT(-747, -747)), (POINT(748, 748)), (POINT(-749, -749)), (POINT(750, 750)), (POINT(-751, -751)), (POINT(752, 752)), (POINT(-753, -753)), (POINT(754, 754)), (POINT(-755, -755)), (POINT(756, 756)), (POINT(-757, -757)), (POINT(758, 758)), (POINT(-759, -759)), (POINT(760, 760)), (POINT(-761, -761)), (POINT(762, 762)), (POINT(-763, -763)), (POINT(764, 764)), (POINT(-765, -765)), (POINT(766, 766)), (POINT(-767, -767)), (POINT(768, 768)), (POINT(-769, -769)), (POINT(770, 770)), (POINT(-771, -771)), (POINT(772, 772)), (POINT(-773, -773)), (POINT(774, 774)), (POINT(-775, -775)), (POINT(776, 776)), (POINT(-777, -777)), (POINT(778, 778)), (POINT(-779, -779)), (POINT(780, 780)), (POINT(-781, -781)), (POINT(782, 782)), (POINT(-783, -783)), (POINT(784, 784)), (POINT(-785, -785)), (POINT(786, 786)), (POINT(-787, -787)), (POINT(788, 788)), (POINT(-789, -789)), (POINT(790, 790)), (POINT(-791, -791)), (POINT(792, 792)), (POINT(-793, -793)), (POINT(794, 794)), (POINT(-795, -795)), (POINT(796, 796)), (POINT(-797, -797)), (POINT(-797, -797));
+
+###############################################################################
+# Inserting POINT Geometry values                                             #
+###############################################################################
+
+SELECT ST_ASTEXT(g) FROM worst_case USE INDEX(g) WHERE 
+ST_Within(g,ST_POLYGONFROMTEXT('POLYGON((-532 -532,-532 532,532 532,532 -532,-532 -532))')) limit 4500;
+
+--echo # Final cleanup
+DROP TABLE worst_case;
diff --git a/sql/item_create.cc b/sql/item_create.cc
index d09b1b9..1f511a3 100644
--- a/sql/item_create.cc
+++ b/sql/item_create.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2016 Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2017 Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -6936,7 +6936,7 @@ Item*
 Create_func_mbr_within::create(THD *thd, Item *arg1, Item *arg2)
 {
   return new (thd->mem_root) Item_func_spatial_mbr_rel(POS(), arg1, arg2,
-                               Item_func::SP_WITHIN_FUNC);
+                               Item_func::SP_NEAREST_NEIGHBOR);
 }
 
 
@@ -6946,7 +6946,7 @@ Item*
 Create_func_within::create(THD *thd, Item *arg1, Item *arg2)
 {
   return new (thd->mem_root) Item_func_spatial_rel(POS(), arg1, arg2,
-                                                   Item_func::SP_WITHIN_FUNC);
+                                                   Item_func::SP_NEAREST_NEIGHBOR);
 }
 
 
diff --git a/sql/item_func.h b/sql/item_func.h
index 382554b..90f64d8 100644
--- a/sql/item_func.h
+++ b/sql/item_func.h
@@ -1,7 +1,7 @@
 #ifndef ITEM_FUNC_INCLUDED
 #define ITEM_FUNC_INCLUDED
 
-/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -63,7 +63,7 @@ public:
 		  INTERVAL_FUNC, ISNOTNULLTEST_FUNC,
 		  SP_EQUALS_FUNC, SP_DISJOINT_FUNC,SP_INTERSECTS_FUNC,
 		  SP_TOUCHES_FUNC,SP_CROSSES_FUNC,SP_WITHIN_FUNC,
-		  SP_CONTAINS_FUNC,SP_COVEREDBY_FUNC,SP_COVERS_FUNC,
+		  SP_CONTAINS_FUNC,SP_COVEREDBY_FUNC,SP_COVERS_FUNC, SP_NEAREST_NEIGHBOR,
                   SP_OVERLAPS_FUNC,
 		  SP_STARTPOINT,SP_ENDPOINT,SP_EXTERIORRING,
 		  SP_POINTN,SP_GEOMETRYN,SP_INTERIORRINGN,
diff --git a/sql/item_geofunc_relchecks.cc b/sql/item_geofunc_relchecks.cc
index 2aaa73b..3af5052 100644
--- a/sql/item_geofunc_relchecks.cc
+++ b/sql/item_geofunc_relchecks.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -52,6 +52,8 @@ const char *Item_func_spatial_mbr_rel::func_name() const
       return "mbrtouches";
     case SP_CROSSES_FUNC:
       return "mbrcrosses";
+    case SP_NEAREST_NEIGHBOR:
+      return "mbrnearestneighbor";
     case SP_OVERLAPS_FUNC:
       return "mbroverlaps";
     case SP_COVERS_FUNC:
@@ -192,6 +194,8 @@ const char *Item_func_spatial_rel::func_name() const
       return "st_touches";
     case SP_CROSSES_FUNC:
       return "st_crosses";
+    case SP_NEAREST_NEIGHBOR:
+      return "st_nearestneighbor";
     case SP_OVERLAPS_FUNC:
       return "st_overlaps";
     default:
@@ -214,8 +218,15 @@ longlong Item_func_spatial_rel::val_int()
   my_bool had_error= false;
   String wkt1, wkt2;
 
+  //short circuit for nearest neighbor
+  if (spatial_rel == SP_WITHIN_FUNC)
+  {
+    goto exit;
+  }
+
   res1= args[0]->val_str(&tmp_value1);
   res2= args[1]->val_str(&tmp_value2);
+
   if ((null_value= (!res1 || args[0]->null_value ||
                     !res2 || args[1]->null_value)))
     goto exit;
diff --git a/sql/opt_range.cc b/sql/opt_range.cc
index 5b9f90d..f827219 100644
--- a/sql/opt_range.cc
+++ b/sql/opt_range.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -665,7 +665,7 @@ public:
   void set_gis_index_read_function(const enum ha_rkey_function rkey_func)
   {
     DBUG_ASSERT(rkey_func >= HA_READ_MBR_CONTAIN &&
-                rkey_func <= HA_READ_MBR_EQUAL);
+                rkey_func <= HA_READ_NEAREST_NEIGHBOR);
     min_flag= GEOM_FLAG;
     rkey_func_flag= rkey_func;
     max_flag= NO_MAX_RANGE;
@@ -6917,6 +6917,7 @@ static bool is_spatial_operator(Item_func::Functype op_type)
   case Item_func::SP_CONTAINS_FUNC:
   case Item_func::SP_COVEREDBY_FUNC:
   case Item_func::SP_COVERS_FUNC:
+  case Item_func::SP_NEAREST_NEIGHBOR:
   case Item_func::SP_OVERLAPS_FUNC:
   case Item_func::SP_STARTPOINT:
   case Item_func::SP_ENDPOINT:
@@ -7327,10 +7328,9 @@ get_mm_leaf(RANGE_OPT_PARAM *param, Item *conf_func, Field *field,
   uchar *str;
   const char *impossible_cond_cause= NULL;
   DBUG_ENTER("get_mm_leaf");
-
   if (param->has_errors())
     goto end;
-
+  
   /*
     We need to restore the runtime mem_root of the thread in this
     function because it evaluates the value of its argument, while
@@ -7393,6 +7393,7 @@ get_mm_leaf(RANGE_OPT_PARAM *param, Item *conf_func, Field *field,
     case Item_func::SP_INTERSECTS_FUNC:
     case Item_func::SP_TOUCHES_FUNC:
     case Item_func::SP_CROSSES_FUNC:
+    case Item_func::SP_NEAREST_NEIGHBOR:
     case Item_func::SP_WITHIN_FUNC:
     case Item_func::SP_CONTAINS_FUNC:
     case Item_func::SP_OVERLAPS_FUNC:
@@ -7667,6 +7668,10 @@ get_mm_leaf(RANGE_OPT_PARAM *param, Item *conf_func, Field *field,
     tree->set_gis_index_read_function(HA_READ_MBR_INTERSECT);
     break;
 
+  case Item_func::SP_NEAREST_NEIGHBOR:
+    tree->set_gis_index_read_function(HA_READ_NEAREST_NEIGHBOR);
+    break;
+
   default:
     break;
   }
diff --git a/sql/sql_executor.cc b/sql/sql_executor.cc
index e72fe85f..135cf72 100644
--- a/sql/sql_executor.cc
+++ b/sql/sql_executor.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1631,7 +1631,21 @@ evaluate_join_record(JOIN *join, QEP_TAB *const qep_tab)
               join, static_cast<int>(qep_tab_idx),
               qep_tab->table()->alias, condition));
 
-  if (condition)
+  if (join->where_cond && join->where_cond->type() == Item::FUNC_ITEM &&
+      down_cast<Item_func*>(join->where_cond)->functype() == Item_func::SP_NEAREST_NEIGHBOR)
+  {
+    if (join->thd->killed)
+    {
+      join->thd->send_kill_message();
+      DBUG_RETURN(NESTED_LOOP_KILLED);
+    }
+
+    /* check for errors evaluating the condition */
+    if (join->thd->is_error())
+      DBUG_RETURN(NESTED_LOOP_ERROR);
+  }
+
+  else if (condition)
   {
     found= MY_TEST(condition->val_int());
 
diff --git a/storage/innobase/btr/btr0btr.cc b/storage/innobase/btr/btr0btr.cc
index f6b02d2..99bae61 100644
--- a/storage/innobase/btr/btr0btr.cc
+++ b/storage/innobase/btr/btr0btr.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2017, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -701,7 +701,6 @@ btr_node_ptr_set_child_page_no(
 /************************************************************//**
 Returns the child page of a node pointer and sx-latches it.
 @return child page, sx-latched */
-static
 buf_block_t*
 btr_node_ptr_get_child(
 /*===================*/
@@ -4390,6 +4389,17 @@ btr_index_rec_validate(
 		return(TRUE);
 	}
 
+  //WL9440jenseven test to print all pages remove after
+  if (dict_index_is_spatial(index))
+  {
+    fprintf(stderr, "the page no is %lu\n", (ulong)page_get_page_no(page));
+    rec_print_mbr_rec(stderr, rec, offsets);
+    fprintf(stderr, "\n");
+    
+}
+
+
+
 #ifdef VIRTUAL_INDEX_DEBUG
 	if (dict_index_has_virtual(index)) {
 		fprintf(stderr, "index name is %s\n", index->name());
diff --git a/storage/innobase/btr/btr0cur.cc b/storage/innobase/btr/btr0cur.cc
index b6f8fe1..e797be4 100644
--- a/storage/innobase/btr/btr0cur.cc
+++ b/storage/innobase/btr/btr0cur.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2017, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 Copyright (c) 2012, Facebook Inc.
 
@@ -1373,9 +1373,9 @@ retry_page_get:
 	}
 
 	/* If this is the desired level, leave the loop */
-
-	ut_ad(height == btr_page_get_level(page_cur_get_page(page_cursor),
-					   mtr));
+  page_cursor = btr_cur_get_page_cur(cursor);
+  height = btr_page_get_level(page_cur_get_page(page_cursor), mtr);
+	ut_ad(height == btr_page_get_level(page_cur_get_page(page_cursor), mtr));
 
 	/* Add Predicate lock if it is serializable isolation
 	and only if it is in the search case */
diff --git a/storage/innobase/gis/gis0geo.cc b/storage/innobase/gis/gis0geo.cc
index 219e187..4f9bc11 100644
--- a/storage/innobase/gis/gis0geo.cc
+++ b/storage/innobase/gis/gis0geo.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2013, 2015, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2015, 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -25,12 +25,26 @@ Created 2013/03/27 Allen Lai and Jimmy Yang
 
 #include "page0types.h"
 #include "gis0geo.h"
+#include "gis0rtree.h"
 #include "page0cur.h"
 #include "ut0rnd.h"
 #include "mach0data.h"
-
-#include <spatial.h>
+#include "item_geofunc.h"
+#include "btr0btr.h"
+#include "btr0cur.h"
+#include "btr0pcur.h"
+#include "btr0sea.h"
+#include "mtr0mtr.h"
+
+#include "row0mysql.h"
+#include "row0sel.h"
+//#include <spatial.h>
 #include <cmath>
+#include <algorithm>
+#include <queue>
+#include <utility>
+#include <typeinfo>
+
 
 /* These definitions are for comparing 2 mbrs. */
 
@@ -59,6 +73,11 @@ Return false if equal, otherwise true. */
 #define EQUAL_CMP(amin, amax, bmin, bmax) \
 (((amin) != (bmin)) || ((amax) != (bmax)))
 
+/* Checks if b is a nearest neighbor of a TODO.
+Return something if something is something. 
+#define NEAREST_NEIGHBOR_CMP(amin, amax, bmin, bmax) \
+(((amin) > (bmin)) || ((amax) < (bmax)))*/
+
 /****************************************************************
 Functions for generating mbr
 ****************************************************************/
@@ -291,6 +310,311 @@ rtree_get_geometry_mbr(
 	return(res);
 }
 
+
+double
+linesegment_distance(point_xy* query, double x1, double x2, double y1, double y2)
+{
+  // Return minimum distance between line segment and point p
+  double xp = query->x;
+  double yp = query->y;
+
+  //This will avoid a square root
+  double l2 = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1); 
+
+  //t is how far along the line that the projection falls
+  double t = ((xp - x2)*(x1 - x2) + (yp - y2)*(y1 - y2)) / l2;
+  t = std::max(0.0, std::min(1.0, t));
+  
+  //The projection of point xp-yp onto the line is the point on the line closest to xp-yp
+  double distance = (xp - (x2 + t*(x1 - x2)))*(xp - (x2 + t*(x1 - x2)))
+    + (yp - (y2 + t*(y1 - y2)))*(yp - (y2 + t*(y1 - y2)));
+  return distance;
+}
+
+double
+calculate_distance(point_xy* query, rtr_mbr_t* targetmbr) /*Starting with just a mbr and a fixed point to make the calculations*/
+//calculate_distance(const Geometry *query, const MBR *target)
+{
+  double mindist= 0;
+
+  if (targetmbr->ymax ==453008)
+  {
+    bool brk = true;
+  }
+  //Distance inside a mbr
+  if ((query->x > targetmbr->xmin) && (query->x < targetmbr->xmax) && (query->y > targetmbr->ymin) && (query->y < targetmbr->ymax))
+  {
+    return 0;
+  }
+  // Distance to a point
+  if (targetmbr->xmax == targetmbr->xmin && targetmbr->ymin ==targetmbr->ymax)
+  {
+    mindist =  sqrt((pow((targetmbr->xmax -query->x), 2))+(pow((targetmbr->ymax - query->y), 2))); //xy-max
+  }
+  
+  else
+  {
+    double qp1p2= linesegment_distance(query, targetmbr->xmin, targetmbr->xmax, targetmbr->ymin, targetmbr->ymin);
+
+    double qp2p3= linesegment_distance(query, targetmbr->xmax, targetmbr->xmax, targetmbr->ymin, targetmbr->ymax);
+
+    double qp3p4= linesegment_distance(query, targetmbr->xmax, targetmbr->xmin, targetmbr->ymax, targetmbr->ymax);
+
+    double qp4p1= linesegment_distance(query, targetmbr->xmin, targetmbr->xmin, targetmbr->ymax, targetmbr->ymin);
+
+    double minlinedist= (qp1p2 < qp2p3)? qp1p2 : qp2p3;
+    double minlinedist1= (qp3p4 < qp4p1)? qp3p4 : qp4p1;
+    //Compare and return the smallest distance
+    mindist = (minlinedist < minlinedist1)? minlinedist : minlinedist1;
+    mindist= sqrt(mindist);
+  }
+  return mindist;
+}
+
+/*******************************************************************************
+Incrementing nearest neighbor algorithm with R-tree                            /
+The inputs to the R-tree incremental nearest neighbor algorithm                /
+are a query object q and an R-tree R containing a set of spatial data objects. /
+/******************************************************************************/
+void
+st_neighbor(
+  point_xy* qobject,
+  dict_index_t*		index_id,
+  rtr_info_t* &rtr_info
+)
+{
+  using std::vector;
+  using std::pair;
+  using std::make_pair;
+  using std::get;
+
+  /*R-tree index*/
+  rec_t*		user_rec;
+  rec_t*		next_rect;
+  mem_heap_t*	heap;
+  ulint		level;
+  dtuple_t*	tuple;
+  dfield_t*		dfield;
+  buf_block_t*	block;
+  page_no_t page_no;
+  page_no_t page_no1;
+  page_no_t page_no2= 0;
+  ulint*		offsets;
+  ulint		offsets1[REC_OFFS_NORMAL_SIZE];
+  rec_offs_init(offsets1);
+  offsets= offsets1;
+  ulint* offs;
+
+  mtr_t mtr;
+  mtr_start(&mtr);
+  page_t* root_page;
+
+  /* For spatial index, initialize structures to track
+  its parents etc. */
+  page_t* match_page = 0;
+  int matched_page = 0;
+  dict_mutex_enter_for_mysql();
+  heap = mem_heap_create(2500);
+  mem_heap_t* heap1 = mem_heap_create(250);
+  root_page = buf_block_get_frame(btr_root_block_get(index_id, RW_NO_LATCH, &mtr));
+  user_rec = page_rec_get_next(page_get_infimum_rec(root_page));
+  level = btr_page_get_level(root_page, mtr);
+  page_no1= index_id->page; //root page number
+  page_no = page_get_page_no(root_page);
+  tuple = dict_index_build_node_ptr(index_id, user_rec, page_no, heap, level);
+  next_rect = page_rec_get_next(user_rec);
+  dict_mutex_exit_for_mysql();
+
+  /*The query object*/
+  priqobj queryobject;
+  queryobject.data.geomboop = qobject;
+  queryobject.type=Value_type::geom_type;
+  pair<priqobj, double> queryobjectpair;
+  queryobjectpair = make_pair(queryobject, 0.0);
+
+  /*Root node from R-tree*/
+  rtr_mbr_t startmbr;
+  rtr_mbr_t mbr;
+  rtr_get_mbr_from_tuple(tuple, &startmbr);
+
+  //The Pair for the mbr and tuple
+  priqobj pqobjrect;
+  pqobjrect.data.rect= user_rec;
+  pqobjrect.type=Value_type::rec_type;
+
+  //The pair for the priqelement 
+  pair<priqobj, double> priqelement;
+  double tmpdistance1 =0;
+  double tmpdistance2 =0;
+
+  if (rtr_info->priority_q.empty())
+  {
+    priqelement = make_pair(pqobjrect, 0.0);
+
+    while (!page_rec_is_supremum_low(page_offset(get<0>(priqelement).data.rect)))
+    {
+      page_no1 = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+      level = btr_page_get_level(page_align(get<0>(priqelement).data.rect), mtr);
+      tuple = dict_index_build_node_ptr(index_id, get<0>(priqelement).data.rect, page_no1, heap, level);
+      //Gets the mbr from the tuple
+      rtr_get_mbr_from_tuple(tuple, &mbr);
+
+      //Calculates the distance from the 
+      tmpdistance1 = calculate_distance(get<0>(queryobjectpair).data.geomboop, &mbr);
+      get<0>(priqelement).type=Value_type::rec_type;
+      //Pushes the records found in this page to the queue with its distance from the query object
+      rtr_info->priority_q.push(make_pair(get<0>(priqelement), tmpdistance1));
+      get<0>(priqelement).data.rect= page_rec_get_next(get<0>(priqelement).data.rect);
+    }
+   }
+  //While the queue is not empty, but where does the pruning come in?
+  while (!rtr_info->priority_q.empty()/*&& result.size()<2000*/)
+  {
+    //Removes first element in the queue 
+    priqelement=rtr_info->priority_q.top();
+
+    /*This calculation is supposed to calculate the distance between the query object and the first element in the pair(a Priqobj)*/
+    offs= rec_get_offsets(get<0>(priqelement).data.rect, index_id, offsets, ULINT_UNDEFINED, &heap);
+
+    rtr_get_mbr_from_rec(get<0>(priqelement).data.rect, offs, &mbr);
+    //GET THE DATA 
+    dfield= dtuple_get_nth_field(tuple, 0);
+    page_no1 = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+    level = btr_page_get_level(page_align(get<0>(priqelement).data.rect), mtr);
+    tuple = dict_index_build_node_ptr(index_id, get<0>(priqelement).data.rect, page_no1, heap, level);
+    rtr_get_mbr_from_tuple(tuple, &mbr);
+    //Calculates the distance from the query object to the other objects(geom)
+
+    //Checks if this element already has a distance calculated
+    if (get<0>(priqelement).type==Value_type::geom_type)
+    {
+      tmpdistance1 = get<1>(rtr_info->priority_q.top());
+    }
+    else
+    {
+      tmpdistance1 = calculate_distance(get<0>(queryobjectpair).data.geomboop, &mbr);
+    }
+    rtr_info->priority_q.pop();
+
+    page_no1 = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+    level = btr_page_get_level(page_align(get<0>(priqelement).data.rect), mtr);
+    tuple = dict_index_build_node_ptr(index_id, get<0>(priqelement).data.rect, page_no1, heap, level);
+    dfield= dtuple_get_nth_field(tuple, 0);
+
+    //if element is an object or "its" bounding rectangle? - I think this means OR the pointer to the object. Only the mbr is stored in the r-tree
+    //if (!(dfield->type.mtype== DATA_GEOMETRY /*DATA_POINT*/)|| !(dfield->type.prtype= 3583)/* && (dfield->type.prtype == DATA_GIS_MBR)*/)
+    if (get<0>(priqelement).type==Value_type::geom_type /*&& (tmpdistance1 = (tmpdistance2 = get<1>(rtr_info->priority_q.top())))*/)
+    {
+      /*If element is the bounding rectangle of object and the queue is not empty
+      and the distance from this element to the query object is BIGGER than
+      the distance from the next object in the queue to the query object. */
+      if (!rtr_info->priority_q.empty() && (tmpdistance1 >= (tmpdistance2 = get<1>(rtr_info->priority_q.top()))) && (get<0>(rtr_info->priority_q.top()).type==Value_type::rec_type))
+      {
+        //Then, push this element WILL THIS EVER BE HIT?
+        rtr_info->priority_q.push(make_pair(get<0>(priqelement), tmpdistance1));
+      }
+      else
+      {
+        //I'm guessing this means that a mbr can contain only one object?
+        //Report Element(or if bounding rectangle, the associated object) as the next nearest object
+        //Return the geometry with the distance (geometry is stored in the data field of the tuple)
+        //how do I return dis result queue 
+        //result.push_back(make_pair(get<0>(priqelement), get<1>(priqelement)));
+       
+        //To initialize the rtr_info
+        page_no1 = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+        const space_id_t	space_id = dict_index_get_space(index_id);
+        const page_id_t		page_id(space_id, page_no1);
+        const page_size_t	page_size(dict_table_page_size(index_id->table));
+
+        if (rtr_info->matches->matched_recs->empty())
+        { 
+          
+          buf_block_t*	block_tmp = btr_block_get(page_id, page_size, RW_NO_LATCH,
+                                              index_id, &mtr);
+
+          rtr_init_match(rtr_info->matches, block_tmp, page_align(get<0>(priqelement).data.rect));
+          match_page = page_align(get<0>(priqelement).data.rect);
+          matched_page = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+        }
+
+        if (matched_page == page_get_page_no(page_align(get<0>(priqelement).data.rect)) || 
+            rtr_info->matches->block.page.id.page_no() == NULL && (rtr_info->matches->used + 100) < UNIV_PAGE_SIZE){
+          
+          rtr_leaf_push_match_rec(get<0>(priqelement).data.rect, rtr_info, 
+                                  offsets, page_is_comp(page_align(get<0>(priqelement).data.rect)), get<1>(priqelement));
+        }
+        else
+        {
+          //Push this popped element back into the queue
+          rtr_info->priority_q.push(priqelement);
+          //Input a save this rec that was not pushed back into the queue. 
+          goto exit;
+        }
+      }
+    }
+    //The algorithm splits open a bounding box and looks inside. The mbr holds only a SQUARE, no data
+    //How about a tuple? A tuple holds the data and the mbr
+    else if (page_is_leaf(page_align(get<0>(priqelement).data.rect)))
+    {
+      //Pushes the objects found in the mbr to the queue with its distance.
+      //Remember only a pointer to the object is stored in the R-tree
+      //This prqelement is a rec witch does not contain other mbr's, 
+      //  this one contains only one mbr and a pointer to the geometry
+
+        //GET THE DATA 
+        dfield= dtuple_get_nth_field(tuple, 0);
+        page_no1 = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+        level = btr_page_get_level(page_align(get<0>(priqelement).data.rect), mtr);
+        tuple = dict_index_build_node_ptr(index_id, get<0>(priqelement).data.rect, page_no1, heap, level);
+        rtr_get_mbr_from_tuple(tuple, &mbr);
+        //Calculates the distance from the query object to the other objects(geom)
+        tmpdistance1 = calculate_distance(get<0>(queryobjectpair).data.geomboop, &mbr);
+        
+        //pqobjtuple.data.tuple = dtuple_get_nth_field(tuple, i);
+        //Pushes the geom objects to the priority queue
+        get<0>(priqelement).type=Value_type::geom_type;
+        rtr_info->priority_q.push(make_pair(get<0>(priqelement), tmpdistance1));
+    }
+    else
+    {
+      //Gets the child page 
+      //If this priqelement is not a leaf node, it is a mbr that contains other mbr
+      block = btr_node_ptr_get_child(get<0>(priqelement).data.rect, index_id, offs, &mtr);
+      page_t* ppage = buf_block_get_frame(block);
+      get<0>(priqelement).data.rect= page_rec_get_next(page_get_infimum_rec(ppage));
+
+      while (!page_rec_is_supremum_low(page_offset(get<0>(priqelement).data.rect)))
+      {
+        //Gets the tuple from the record stored in priqelement and makes a tuple
+        page_no1 = page_get_page_no(page_align(get<0>(priqelement).data.rect));
+        level = btr_page_get_level(page_align(get<0>(priqelement).data.rect), mtr);
+        tuple = dict_index_build_node_ptr(index_id, get<0>(priqelement).data.rect, page_no1, heap, level);
+        //Gets the mbr from the tuple
+        rtr_get_mbr_from_tuple(tuple, &mbr);
+
+        //Calculates the distance from the 
+        tmpdistance1 = calculate_distance(get<0>(queryobjectpair).data.geomboop, &mbr);
+        if (mbr.xmax==mbr.xmin && mbr.ymin==mbr.ymax)
+        {
+          get<0>(priqelement).type=Value_type::geom_type;
+        }
+        else
+        {
+          get<0>(priqelement).type=Value_type::rec_type;
+        }
+        
+        //Pushes the records found in this page to the queue with its distance from the query object
+        rtr_info->priority_q.push(make_pair(get<0>(priqelement), tmpdistance1));
+        get<0>(priqelement).data.rect= page_rec_get_next(get<0>(priqelement).data.rect);
+      }
+    }
+  }
+  exit:
+  mem_heap_free(heap);
+  mtr_commit(&mtr);
+}
+
 /*************************************************************//**
 Calculate Minimal Bounding Rectangle (MBR) of the spatial object
 stored in "well-known binary representation" (wkb) format.
@@ -673,6 +997,12 @@ rtree_key_cmp(
 			}
 
 			break;
+    /*case PAGE_CUR_NEAREST_NEIGHBOR:
+      if (NEAREST_NEIGHBOR_CMP(/*insert something ))
+      {
+        return(1);
+      }*/
+
 		default:
 			/* if unknown comparison operator */
 			ut_ad(0);
diff --git a/storage/innobase/gis/gis0rtree.cc b/storage/innobase/gis/gis0rtree.cc
index cc9c56b..3dc23f1 100644
--- a/storage/innobase/gis/gis0rtree.cc
+++ b/storage/innobase/gis/gis0rtree.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -1862,6 +1862,7 @@ rtr_estimate_n_rows_in_range(
 	case PAGE_CUR_INTERSECT:
 	case PAGE_CUR_WITHIN:
 	case PAGE_CUR_MBR_EQUAL:
+  case PAGE_CUR_NEAREST_NEIGHBOR:
 		break;
 	default:
 		return(HA_POS_ERROR);
@@ -1942,6 +1943,7 @@ rtr_estimate_n_rows_in_range(
 			case PAGE_CUR_DISJOINT:
 				break;
 
+      case PAGE_CUR_NEAREST_NEIGHBOR:
 			case PAGE_CUR_WITHIN:
 			case PAGE_CUR_MBR_EQUAL:
 				if (rtree_key_cmp(
@@ -1951,6 +1953,7 @@ rtr_estimate_n_rows_in_range(
 					area += 1;
 				}
 
+
 				break;
 
 			default:
@@ -1958,6 +1961,11 @@ rtr_estimate_n_rows_in_range(
 			}
 		} else {
 			switch (mode) {
+     /* case PAGE_CUR_NEAREST_NEIGHBOR:
+        area += rtree_area_overlapping(range_mbr_ptr,
+                                       field, DATA_MBR_LEN) / rec_area;
+        break;
+        */
 			case PAGE_CUR_CONTAIN:
 			case PAGE_CUR_INTERSECT:
 				area += rtree_area_overlapping(range_mbr_ptr,
@@ -1970,6 +1978,7 @@ rtr_estimate_n_rows_in_range(
 						field, DATA_MBR_LEN) / rec_area;
 				break;
 
+      case PAGE_CUR_NEAREST_NEIGHBOR:
 			case PAGE_CUR_WITHIN:
 			case PAGE_CUR_MBR_EQUAL:
 				if (rtree_key_cmp(
@@ -1978,7 +1987,6 @@ rtr_estimate_n_rows_in_range(
 				    == 0) {
 					area += range_area / rec_area;
 				}
-
 				break;
 			default:
 				ut_error;
diff --git a/storage/innobase/gis/gis0sea.cc b/storage/innobase/gis/gis0sea.cc
index c3cf2db..65c9ee5 100644
--- a/storage/innobase/gis/gis0sea.cc
+++ b/storage/innobase/gis/gis0sea.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -39,6 +39,7 @@ Created 2014/01/16 Jimmy Yang
 #include "trx0trx.h"
 #include "srv0mon.h"
 #include "gis0geo.h"
+#include "spatial.h"
 
 #endif /* UNIV_HOTBACKUP */
 
@@ -111,6 +112,30 @@ rtr_pcur_getnext_from_path(
 	bool		for_delete = false;
 	bool		for_undo_ins = false;
 
+
+  /*if (rtr_info->retrived_matches>=1000)
+  {
+    pq g; 
+    rtr_info->retrived_matches=0;
+    rtr_info->priority_q = g;
+    return(false);
+  }*/
+  if (rtr_info->path->empty() && !rtr_info->priority_q.empty())
+  {
+    using std::get;
+    //The pair for the priqelement 
+    pair<priqobj, double> priqelement;
+    priqelement=rtr_info->priority_q.top();
+    //rtr_info->priority_q.pop();
+    rtr_non_leaf_stack_push(
+      rtr_info->path,
+      page_get_page_no(page_align(get<0>(priqelement).data.rect)),
+      rtr_get_current_ssn_id(index), level-1, 1,
+      NULL, 0);
+  }
+
+
+
 	/* exhausted all the pages to be searched */
 	if (rtr_info->path->empty()) {
 		return(false);
@@ -152,7 +177,7 @@ rtr_pcur_getnext_from_path(
 
 	const page_size_t&	page_size = dict_table_page_size(index->table);
 
-	/* Pop each node/page to be searched from "path" structure
+  /* Pop each node/page to be searched from "path" structure
 	and do a search on it. Please note, any pages that are in
 	the "path" structure are protected by "page" lock, so tey
 	cannot be shrunk away */
@@ -973,6 +998,7 @@ rtr_create_rtr_info(
 
 	rtr_info->path = UT_NEW_NOKEY(rtr_node_path_t());
 	rtr_info->parent_path = UT_NEW_NOKEY(rtr_node_path_t());
+  UT_NEW_NOKEY(pq());
 	rtr_info->need_prdt_lock = need_prdt;
 	mutex_create(LATCH_ID_RTR_PATH_MUTEX,
 		     &rtr_info->rtr_path_mutex);
@@ -1010,7 +1036,7 @@ rtr_init_rtr_info(
 	dict_index_t*	index,		/*!< in: index structure */
 	bool		reinit)		/*!< in: Whether this is a reinit */
 {
-	ut_ad(rtr_info);
+	//ut_ad(rtr_info);
 
 	if (!reinit) {
 		/* Reset all members. */
@@ -1101,6 +1127,15 @@ rtr_clean_rtr_info(
 		rtr_info->matches->valid = false;
 		rtr_info->matches->matched_recs->clear();
 	}
+  if (!rtr_info->priority_q.empty())
+  {
+    //UT_DELETE(&rtr_info->priority_q);
+    rtr_info->priority_q= pq();
+   /* while (!rtr_info->priority_q.empty())
+    {
+      rtr_info->priority_q.pop();
+    }*/
+  }
 
 	if (index) {
 		index->rtr_track->rtr_active->remove(rtr_info);
@@ -1422,14 +1457,14 @@ search_again:
 
 /****************************************************************//**
 Copy the leaf level R-tree record, and push it to matched_rec in rtr_info */
-static
 void
 rtr_leaf_push_match_rec(
 /*====================*/
 	const rec_t*	rec,		/*!< in: record to copy */
 	rtr_info_t*	rtr_info,	/*!< in/out: search stack */
 	ulint*		offsets,	/*!< in: offsets */
-	bool		is_comp)	/*!< in: is compact format */
+	bool		is_comp,    /*!< in: is compact format */
+  double distance)	  /*!< in: distance to query */
 {
 	byte*		buf;
 	matched_rec_t*	match_rec = rtr_info->matches;
@@ -1449,9 +1484,15 @@ rtr_leaf_push_match_rec(
 
 	rtr_rec.r_rec = copy;
 	rtr_rec.locked = false;
+  rtr_rec.distance= distance; 
 
-	match_rec->matched_recs->push_back(rtr_rec);
-	match_rec->valid = true;
+	
+  /*This changes the functionality to push the record to the front of the queue. Not sure if this is the right way to go.
+    The records are now printed in the right order, but the last match on each page is returned first.
+  */
+  //match_rec->matched_recs->push_back(rtr_rec);
+  match_rec->matched_recs->insert(match_rec->matched_recs->begin(), rtr_rec);
+  match_rec->valid = true;
 
 	data_len = rec_offs_data_size(offsets) + rec_offs_extra_size(offsets);
 	match_rec->used += data_len;
@@ -1583,7 +1624,6 @@ rtr_copy_buf(
 /****************************************************************//**
 Generate a shadow copy of the page block header to save the
 matched records */
-static
 void
 rtr_init_match(
 /*===========*/
@@ -1679,6 +1719,54 @@ rtr_cur_search_with_match(
 	space_id_t	space = block->page.id.space();
 	page_cur_mode_t	orig_mode = mode;
 	const rec_t*	first_rec = NULL;
+  /*
+  //TESTING 
+  mtr_t mtr;
+  mtr_start(&mtr);
+  page_t* root_page;
+  page_t* boop;
+
+   For spatial index, initialize structures to track
+  its parents etc. 
+
+  mem_heap_t* heap1 = mem_heap_create(250);
+  root_page = buf_block_get_frame(btr_root_block_get(index, RW_NO_LATCH, &mtr));
+  rec_t* user_rec = page_rec_get_next(page_get_infimum_rec(root_page));
+  ulint level1 = btr_page_get_level(root_page, mtr);
+  page_no_t page_no = page_get_page_no(root_page);
+  dtuple_t* tuple1 = dict_index_build_node_ptr(index, user_rec, page_no, heap1, level1);
+
+  rtr_mbr_t mbr1;
+  rtr_get_mbr_from_tuple(tuple, &mbr1);
+  //rtr_get_mbr_from_rec(user_rec, 0, &mbr1);
+
+  */
+  if (mode == PAGE_CUR_NEAREST_NEIGHBOR)
+  {
+    point_xy geom;
+    geom.x= -739851300;
+    geom.y=  407588960;
+
+    st_neighbor(&geom, index, rtr_info);
+
+    if (rtr_info->matches->matched_recs->empty()&& rtr_info->priority_q.empty())
+    {
+      return(false);
+    }
+
+    /* There are matched records */
+    matched_rec_t*	match_rec = rtr_info->matches;
+
+    rtr_rec_t	test_rec;
+
+    test_rec = match_rec->matched_recs->back();
+    match_rec->matched_recs->back();
+    page_cur_position(test_rec.r_rec, &match_rec->block,
+                      cursor);
+    rtr_info->matches->matched_recs->pop_back();
+      return(true);
+  }
+
 
 	rec_offs_init(offsets_);
 
@@ -1880,7 +1968,7 @@ rtr_cur_search_with_match(
 						ULINT_UNDEFINED, &heap);
 					rtr_leaf_push_match_rec(
 						rec, rtr_info, offsets,
-						page_is_comp(page));
+						page_is_comp(page), 0);
 				}
 
 				last_match_rec = rec;
@@ -1946,6 +2034,19 @@ rtr_cur_search_with_match(
 				goto func_exit;
 			}
 
+      //TEST
+      mtr_t mtr;
+      mtr_start(&mtr);
+      page_t* root_page = buf_block_get_frame(btr_root_block_get(index, RW_NO_LATCH, &mtr));
+      rec_t* user_rec = page_rec_get_next(page_get_infimum_rec(root_page));
+      ulint level1 = btr_page_get_level(root_page, mtr);
+      page_no_t page_no = page_get_page_no(root_page);
+      mem_heap_t* heap1 = mem_heap_create(250);
+      dtuple_t* tupl = dict_index_build_node_ptr(index, user_rec, page_no, heap1, level1);
+      rtr_mbr_t startmbr;
+      rtr_get_mbr_from_tuple(tupl, &startmbr);
+
+
 			/* There are matched records */
 			matched_rec_t*	match_rec = rtr_info->matches;
 
diff --git a/storage/innobase/handler/ha_innodb.cc b/storage/innobase/handler/ha_innodb.cc
index 967918e..49b847e 100644
--- a/storage/innobase/handler/ha_innodb.cc
+++ b/storage/innobase/handler/ha_innodb.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2000, 2016 Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2000, 2017 Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, 2009 Google Inc.
 Copyright (c) 2009, Percona Inc.
 Copyright (c) 2012, Facebook Inc.
@@ -8955,7 +8955,7 @@ convert_search_mode_to_innobase(
 	case HA_READ_MBR_INTERSECT:
 		return(PAGE_CUR_INTERSECT);
 	case HA_READ_MBR_WITHIN:
-		return(PAGE_CUR_WITHIN);
+		return(PAGE_CUR_NEAREST_NEIGHBOR); //PAGE_CUR_WITHIN
 	case HA_READ_MBR_DISJOINT:
 		return(PAGE_CUR_DISJOINT);
 	case HA_READ_MBR_EQUAL:
@@ -8964,6 +8964,8 @@ convert_search_mode_to_innobase(
 		return(PAGE_CUR_UNSUPP);
         case HA_READ_INVALID:
 		return(PAGE_CUR_UNSUPP);
+  case HA_READ_NEAREST_NEIGHBOR:
+    return(PAGE_CUR_NEAREST_NEIGHBOR);
 	/* do not use "default:" in order to produce a gcc warning:
 	enumeration value '...' not handled in switch
 	(if -Wswitch or -Wall is used) */
@@ -9137,7 +9139,6 @@ ha_innobase::index_read(
 
 			m_prebuilt->ins_sel_stmt = thd_is_ins_sel_stmt(
 				m_user_thd);
-
 			ret = row_search_mvcc(
 				buf, mode, m_prebuilt, match_mode, 0);
 
@@ -14233,20 +14234,39 @@ ha_innobase::records_in_range(
 		max_key ? max_key->flag : HA_READ_KEY_EXACT);
 
 	if (mode1 != PAGE_CUR_UNSUPP && mode2 != PAGE_CUR_UNSUPP) {
-
-		if (dict_index_is_spatial(index)) {
-			/*Only min_key used in spatial index. */
-			n_rows = rtr_estimate_n_rows_in_range(
-				index, range_start, mode1);
-		} else {
+    
+    if (dict_index_is_spatial(index))
+    {
+      /*Only min_key used in spatial index. */
+      n_rows = rtr_estimate_n_rows_in_range(
+        index, range_start, mode1);
+    }
+    else {
 			n_rows = btr_estimate_n_rows_in_range(
 				index, range_start, mode1, range_end, mode2);
 		}
+
 	} else {
 
 		n_rows = HA_POS_ERROR;
 	}
-
+  /*if (dict_index_is_spatial(index) && mode1 == PAGE_CUR_NEAREST_NEIGHBOR && m_prebuilt->index != NULL)
+  {
+    /*Only min_key used in spatial index. 
+    //m_prebuilt->index= index;
+    point_xy geom;
+    geom.x=50000;
+    geom.y=10000;
+    //btr_pcur_store_position(m_prebuilt->pcur, mtr);
+    //btr_cur_t* cursor = btr_pcur_get_btr_cur(m_prebuilt->pcur);
+    //m_prebuilt = row_create_prebuilt(index->table, table->s->reclength);
+    
+    st_neighbor(&geom, m_prebuilt/*, mtr);
+    m_prebuilt->rtr_info->search_mode=mode1;
+    //btr_pcur_store_position(m_prebuilt->pcur, mtr);
+    //st_neighbor(&geom, m_prebuilt, mtr);
+
+  }*/
 	mem_heap_free(heap);
 
 	DBUG_EXECUTE_IF(
diff --git a/storage/innobase/handler/ha_innodb.h b/storage/innobase/handler/ha_innodb.h
index 1eab0bc..bf8601b 100644
--- a/storage/innobase/handler/ha_innodb.h
+++ b/storage/innobase/handler/ha_innodb.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2000, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2000, 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
diff --git a/storage/innobase/include/btr0btr.h b/storage/innobase/include/btr0btr.h
index ac22e3a..252055f 100644
--- a/storage/innobase/include/btr0btr.h
+++ b/storage/innobase/include/btr0btr.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2017, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2012, Facebook Inc.
 
 This program is free software; you can redistribute it and/or modify it under
@@ -322,6 +322,15 @@ btr_node_ptr_get_child_page_no(
 @param[in,out]	mtr			mini-transaction
 @return page number of the created root
 @retval FIL_NULL if did not succeed */
+
+buf_block_t*
+btr_node_ptr_get_child(
+  /*===================*/
+  const rec_t*	node_ptr,/*!< in: node pointer */
+  dict_index_t*	index,	/*!< in: index */
+  const ulint*	offsets,/*!< in: array returned by rec_get_offsets() */
+  mtr_t*		mtr);	/*!< in: mtr */
+
 ulint
 btr_create(
 	ulint			type,
diff --git a/storage/innobase/include/gis0geo.h b/storage/innobase/include/gis0geo.h
index 08895af..6a713df 100644
--- a/storage/innobase/include/gis0geo.h
+++ b/storage/innobase/include/gis0geo.h
@@ -1,5 +1,5 @@
 /*****************************************************************************
-Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -25,6 +25,11 @@ The r-tree define from MyISAM
 
 #include "my_global.h"
 #include "string.h"
+#include "spatial.h"
+//#include "gis0type.h"
+//#include <string>
+//#include "btr0cur.h"
+//#include "row0mysql.h"
 
 #define SPTYPE HA_KEYTYPE_DOUBLE
 #define SPLEN  8
@@ -149,6 +154,45 @@ rtree_area_increase(
 	int		a_len,		/*!< in: mbr length. */
 	double*		ab_area);	/*!< out: increased area. */
 
+
+
+
+//Priority queue object
+enum class Value_type { geom_type, rec_type };
+  struct priqobj
+  {
+   // priqobj(const priqobj &pobj);
+    priqobj() {}
+    ~priqobj(){}
+    Value_type type;
+    union
+    {
+      point_xy*	geomboop;			//!< A geometry type
+      rec_t* rect;
+      //MBR* mbr;
+    }data;
+  };
+
+/*************************************************************//**
+Calculates the nearest neighbor to the query object and
+returns them in a sorted list */
+  void
+    st_neighbor(
+      point_xy* qobject,
+      dict_index_t*		index,
+      struct rtr_info* &rtr_info
+    );
+
+///COMPARE DISTANCE
+class CompareDist
+{
+public:
+  bool operator()(std::pair<priqobj, double> n1, std::pair<priqobj, double> n2)
+  {
+    return n1.second>n2.second;
+  }
+};
+
 /** Calculates overlapping area
 @param[in]	a	mbr a
 @param[in]	b	mbr b
diff --git a/storage/innobase/include/gis0rtree.h b/storage/innobase/include/gis0rtree.h
index 64062fd..0082de8 100644
--- a/storage/innobase/include/gis0rtree.h
+++ b/storage/innobase/include/gis0rtree.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2014, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2014, 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -70,7 +70,7 @@ Created 2013/03/27 Jimmy Yang and Allen Lai
 
 /* Define it for rtree search mode checking. */
 #define RTREE_SEARCH_MODE(mode)					\
-	(((mode) >= PAGE_CUR_CONTAIN) && ((mode <= PAGE_CUR_RTREE_GET_FATHER)))
+	(((mode) >= PAGE_CUR_CONTAIN) && ((mode <= PAGE_CUR_NEAREST_NEIGHBOR)))
 
 /* Geometry data header */
 #define	GEO_DATA_HEADER_SIZE	4
@@ -207,6 +207,27 @@ rtr_get_father_node(
 @param[in]	child_no	child page no
 @param[in]	cursor		position cursor
 @param[in]	mbr_inc		MBR needs to be enlarged */
+
+
+/****************************************************************//**
+ Generate a shadow copy of the page block header to save the
+ matched records */
+void
+rtr_init_match(
+  /*===========*/
+  matched_rec_t*		matches,/*!< in/out: match to initialize */
+  const buf_block_t*	block,	/*!< in: buffer block */
+  const page_t*		page);	/*!< in: buffer page */
+
+void
+rtr_leaf_push_match_rec(
+  /*====================*/
+  const rec_t*	rec,		/*!< in: record to copy */
+  rtr_info_t*	rtr_info,	/*!< in/out: search stack */
+  ulint*		offsets,	/*!< in: offsets */
+  bool		is_comp,    /*!< in: is compact format */
+  double distance);
+
 UNIV_INLINE
 void
 rtr_non_leaf_stack_push(
diff --git a/storage/innobase/include/gis0type.h b/storage/innobase/include/gis0type.h
index cb3d30b..30767e6 100644
--- a/storage/innobase/include/gis0type.h
+++ b/storage/innobase/include/gis0type.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2014, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2014, 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -69,6 +69,7 @@ typedef std::vector<node_visit_t, ut_allocator<node_visit_t> >	rtr_node_path_t;
 typedef	struct rtr_rec {
 		rec_t*	r_rec;		/*!< matched record */
 		bool	locked;		/*!< whether the record locked */
+    double distance;
 } rtr_rec_t;
 
 typedef std::vector<rtr_rec_t, ut_allocator<rtr_rec_t> >	rtr_rec_vector;
@@ -105,6 +106,9 @@ modification (split, shrink), we always latch left, current
 and right pages */
 #define RTR_LEAF_LATCH_NUM	3
 
+using std::vector;
+using std::pair;
+typedef std::priority_queue<pair<priqobj, double>, vector<pair<priqobj, double>>, CompareDist> pq;
 /** Vectors holding the matching internal pages/nodes and leaf records */
 typedef	struct rtr_info{
 	rtr_node_path_t*path;	/*!< vector holding matching pages */
@@ -112,6 +116,7 @@ typedef	struct rtr_info{
 				/*!< vector holding parent pages during
 				search */
 	matched_rec_t*	matches;/*!< struct holding matching leaf records */
+ // int retrived_matches;/*!< count of how many matches are retrieved */
 	ib_mutex_t	rtr_path_mutex;
 				/*!< mutex protect the "path" vector */
 	buf_block_t*	tree_blocks[RTR_MAX_LEVELS + RTR_LEAF_LATCH_NUM];
@@ -140,6 +145,7 @@ typedef	struct rtr_info{
 				/*!< search tuple being used */
 	page_cur_mode_t	search_mode;
 				/*!< current search mode */
+  pq priority_q;
 } rtr_info_t;
 
 typedef std::list<rtr_info_t*, ut_allocator<rtr_info_t*> >	rtr_info_active;
diff --git a/storage/innobase/include/page0types.h b/storage/innobase/include/page0types.h
index 9426fe4..bcfd807 100644
--- a/storage/innobase/include/page0types.h
+++ b/storage/innobase/include/page0types.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1994, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1994, 2017, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -172,7 +172,8 @@ enum page_cur_mode_t {
 	PAGE_CUR_MBR_EQUAL		= 11,
 	PAGE_CUR_RTREE_INSERT		= 12,
 	PAGE_CUR_RTREE_LOCATE		= 13,
-	PAGE_CUR_RTREE_GET_FATHER	= 14
+	PAGE_CUR_RTREE_GET_FATHER	= 14,
+  PAGE_CUR_NEAREST_NEIGHBOR = 15
 };
 
 /** Compressed page descriptor */
diff --git a/storage/innobase/row/row0sel.cc b/storage/innobase/row/row0sel.cc
index 0df3ff0..e6fc4a2 100644
--- a/storage/innobase/row/row0sel.cc
+++ b/storage/innobase/row/row0sel.cc
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 1997, 2016, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 1997, 2017, Oracle and/or its affiliates. All Rights Reserved.
 Copyright (c) 2008, Google Inc.
 
 Portions of this file contain modifications contributed and copyrighted by
diff --git a/storage/perfschema/pfs_engine_table.cc b/storage/perfschema/pfs_engine_table.cc
index 4aeba9c..aeb62e4 100644
--- a/storage/perfschema/pfs_engine_table.cc
+++ b/storage/perfschema/pfs_engine_table.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2008, 2017, Oracle and/or its affiliates. All rights reserved.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -1122,6 +1122,7 @@ int PFS_engine_table::index_read(KEY *key_infos,
   DBUG_ASSERT(find_flag != HA_READ_MBR_WITHIN);
   DBUG_ASSERT(find_flag != HA_READ_MBR_DISJOINT);
   DBUG_ASSERT(find_flag != HA_READ_MBR_EQUAL);
+  DBUG_ASSERT(find_flag != HA_READ_NEAREST_NEIGHBOR);
 
   KEY *key_info= key_infos + index;
   m_index->set_key_info(key_info);
